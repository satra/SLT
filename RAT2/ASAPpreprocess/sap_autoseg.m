function bRedoOTL = sap_autoseg(braindatafile,bInteractive)
% SAP_AUTOSEG An attempt at automatic segmentation of brain given ...
%   braindatafile: actual volume data
%   brainmaskfile: underestimated mask generated by SPM

% Satrajit Ghosh, SpeechLab, Boston University. (c)2001
% $Header: /SpeechLabToolkit/ASAP/preprocess.1/sap_autoseg.m 2     10/08/02 2:37p Satra $

% $NoKeywords: $

% Setup globals
global DEBUG
spm_defaults;

if nargin<2,
    bInteractive = 0;
end;

bRedoAll = 0;
bRedoWmask = 0;
bRedoBrainmask = 0;
bRedoCortex = 0;
bRedoOTL = 0;
bRedoSurf = 0;
%end;

[pth,nm,xt] = fileparts(braindatafile);
suffix = [pth,filesep,nm,'_'];
%braindatafile = 'braindata.mat';
brainmaskfile   = [suffix,'brainmask.mat'];
brainmaskfile2  = [suffix,'brainmask2.mat'];
wmmaskfile      = [suffix,'wmmask.mat'];
extmaskfile     = [suffix,'extmask.mat'];
cortexfile      = [suffix,'cortex.mat'];
otlfile         = [suffix,'otl.mat'];
surffile        = [suffix,'brainsurf.mat'];
leftsurffile    = [suffix,'leftsurf.mat'];
rightsurffile   = [suffix,'rightsurf.mat'];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 1: Get white matter mask %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   In this step, the brainmask returned by SPM is used to
%   determine the distribution of white matter.

if ~(exist(wmmaskfile,'file') & exist(extmaskfile,'file')) | ...
        bRedoWmask | bRedoAll,
    V = spm_vol(braindatafile);
    braindata = spm_read_vols(V);
    %load(braindatafile);
    load(brainmaskfile);
    
    % Create a VOI
    disp('creating VOI');
    VOI = braindata.*double(brainmask>0);
    clear brainmask braindata
    
    disp('Finding GWIF value');
    max_vol     = max(VOI(:));
    nHistBins   = ceil(max_vol);
    
    % Find histogram of nonzero voxels
    [h,x] = hist(VOI(find(VOI(:))),nHistBins);
    idx = find(h>(0.05*max(h)));
    
    x1 = linspace(x(idx(1)),x(idx(end)),100);
    h1 = interp1(x(idx),h(idx),x1);
    
    x2 = getGWIF(h1);
    % determine gray-white interface value
    % The following needs to be modified
    %gwif2 = max_vol*getGWIF(h1)/nHistBins;
    gwif2 = max_vol*x1(x2)/nHistBins;
    
    f1 = figure('windowstyle','modal','name','Histogram','numbertitle','off');
    plot(x,h);hold on;
    plot([gwif2(1) gwif2(1)],[0,max(h)],'r');
    plot([gwif2(2) gwif2(2)],[0,max(h)],'r');
    pause(2);
    close(f1);
    clear h x f1 x1 h1 x2
    
    % determine largest connected component as the white matter mask
    disp('Finding white matter mask');
    wmmask = getLargestLabel(uint8(VOI>gwif2(1) & VOI<gwif2(2)));
    clear VOI 
    
    % Create a volume such that all internal holes are filled. This ensure
    % that the white matter mask consists of most subcortical elements
    % In addition create an extended mask such that it extends beyond the
    % skull at most places around the head.
    [wmmask1,extMask] = fillVolume(wmmask,1);
    clear wmmask1
    %[wmmask] = fillVolume(wmmask,0,2);
    
    save(wmmaskfile,'wmmask');
    save(extmaskfile,'extMask');
    clear wmmask extMask
else,
    disp('wmmask and extMask exists .. skipping');
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 2: Get brain mask %
%%%%%%%%%%%%%%%%%%%%%%%%%%
if ~exist(brainmaskfile2,'file') | bRedoBrainmask | bRedoAll,
    disp('Finding brain mask');
    brainmask = getmask02(braindatafile,wmmaskfile,extmaskfile);
    brainmask = fillVolume(brainmask);
    
    save(brainmaskfile2,'brainmask');
    clear brainmask
else,
    disp('brainmask2 exists .. skipping');
end;

% get gray-matter mask
if ~exist(cortexfile,'file') | bRedoCortex | bRedoAll,
    disp('Finding gray matter mask');
    load(brainmaskfile2);
    load(wmmaskfile);
    gmmask = uint8(double(brainmask)-double(wmmask));
    
    V = spm_vol(braindatafile);
    braindata = spm_read_vols(V);
    %load(braindatafile);
    VOI = double(braindata).*double(gmmask);
    clear braindata gmmask
    
    meangm = mean(VOI(find(VOI(:))));
    stdgm = std(VOI(find(VOI(:))));
    
    gmmin = meangm-stdgm;
    gmmax = meangm+stdgm;
    
    gwmask = uint8(((VOI>gmmin).*double(brainmask))>0);
    clear VOI brainmask meangm stdgm gmmin gmmax
    
    %gwmask = fillVolume(gwmask,0,2);
    cortexmask = uint8(double(gwmask)-double(wmmask));
    clear gwmask wmmask
    
    cortexmask = uint8(smooth3(double(cortexmask))>0.45);
    cortexmask = getLargestLabel(cortexmask);
    
    save(cortexfile,'cortexmask');
    clear cortexmask
else,
    disp('cortex exists .. skipping');
end;

disp('done non-interactive session');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 3: Get brain mask interactively %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if bInteractive,
    [bchange,white_val,gray_val] = getInteractiveValues(braindatafile,brainmaskfile2,cortexfile);
    
    % recreate wmmask and cortexmask based on the new values
    if bchange,
        V = spm_vol(braindatafile);
        braindata = spm_read_vols(V);
        %load(braindatafile);
        load(brainmaskfile2);
        
        VOI = zeros(size(braindata));
        
        wmmask = uint8(zeros(size(braindata)));
        hproc = uiwaitbar('Thresholding white matter');
        for imgnum=1:length(white_val),
            VOI(:,imgnum,:) = braindata(:,imgnum,:).*double(brainmask(:,imgnum,:)>0);
            wmmask(:,imgnum,:) = uint8(VOI(:,imgnum,:)>white_val(imgnum));
            uiwaitbar(imgnum/length(white_val),hproc);
        end;
        
        %wmmask = uint8(smooth3(VOI>gwif)>0.7);
        wmmask = getLargestLabel(wmmask);
        clear  braindata white_val
        
        %wmmask = fillVolume(wmmask,0,2);
        save(wmmaskfile,'wmmask');
        
        gwmask = uint8(zeros(size(wmmask)));
        uiwaitbar(0,hproc,'title','Thresholding gray matter');
        for imgnum=1:length(gray_val),
            gwmask(:,imgnum,:) = uint8(((VOI(:,imgnum,:)>=gray_val(imgnum)).*double(brainmask(:,imgnum,:)))>0);
            uiwaitbar(imgnum/length(gray_val),hproc);
        end;
        delete(hproc);
        clear VOI brainmask gray_val
        
        %gwmask = fillVolume(gwmask,0,2);
        cortexmask = uint8(double(gwmask)-double(wmmask));
        clear gwmask wmmask
        
        cortexmask = uint8(smooth3(double(cortexmask))>0.45);
        cortexmask = getLargestLabel(cortexmask);
        
        save(cortexfile,'cortexmask','-APPEND');
        clear cortexmask
        bRedoOTL = 1;
    end;
end;

if ~exist(otlfile,'file') | bRedoOTL | bRedoAll,
    disp('Starting otl extraction');
    load(cortexfile);
    
    idx = find(cortexmask(:));
    [x,y,z] = ind2sub(size(cortexmask),idx);
    
    Image.Crop_X = [max(1,min(x)-5):min(max(x)+5,size(cortexmask,1))];
    Image.Crop_Y = [max(1,min(y)-5):min(max(y)+5,size(cortexmask,2))];
    Image.Crop_Z = [max(1,min(z)-5):min(max(z)+5,size(cortexmask,3))];
    cortexmask = cortexmask(Image.Crop_X,Image.Crop_Y,Image.Crop_Z);
    
    hproc = uiwaitbar('Getting contours');
    for imgnum = 1:size(cortexmask,2),
        otl(imgnum).lines = {};
        otl(imgnum).alive = [];
        c = contourc(double(squeeze(cortexmask(:,imgnum,:))'),[1 1]);
        limit = size(c,2);
        i = 1;
        j = 0;
        while(i < limit)
            z_level = c(1,i);
            npoints = c(2,i);
            nexti = i+npoints+1;
            
            xdata = c(1,i+1:i+npoints);
            ydata = c(2,i+1:i+npoints);
            j = j+1;
            otl(imgnum).lines{j}.ptlist = [xdata;ydata]';
            i = nexti;
        end
        otl(imgnum).alive = ones(1,length(otl(imgnum).lines));
        uiwaitbar(imgnum/size(cortexmask,2),hproc);
    end;
    delete(hproc);
    clear cortexmask;
    
    crop = Image;
    save(otlfile,'otl','crop');
    clear otl otl1 Image crop
    disp('Done otl extraction');
end;

try
    if ~exist(surffile,'file') | bRedoSurf | bRedoAll,
        disp('Getting surface info.');
        load(wmmaskfile,'wmmask');
        
        disp('Smoothing surface');
        wmmask = uint8(smooth3(double(wmmask))>0.5);
        wmmask = getLargestLabel(wmmask);
        
        [surfstruct,mc,inflatedSurf] = surfExtract(wmmask);
        
        save(surffile,'surfstruct','mc','inflatedSurf');
        showVertexValue(inflatedSurf, mc);view(-113,9);
        camlight headlight;
        pause(1);
        
        disp('Performing separate surface extraction');
        lrmask = uint8(zeros(size(wmmask)));
        lrmask(1:round((end/2)),:,:) = 1;
        leftmask = uint8(double(wmmask).*double(lrmask==1));
        rightmask = uint8(double(wmmask).*double(lrmask==0));
        clear lrmask wmmask
        
        disp('Extracting left hemisphere');
        [surfstruct,mc,inflatedSurf] = surfExtract(leftmask);
        save(leftsurffile,'surfstruct','mc','inflatedSurf');
        showVertexValue(inflatedSurf, mc);view(-113,9);
        camlight headlight;
        pause(1);
        
        disp('Extracting right hemisphere');
        [surfstruct,mc,inflatedSurf] = surfExtract(rightmask);
        save(rightsurffile,'surfstruct','mc','inflatedSurf');
        showVertexValue(inflatedSurf, mc);view(113,9);
        camlight headlight;
        pause(1);
        
        disp('Surface processed.');
    else,
        disp('Surface data exists .. skipping.');
    end;    
catch
    disp(['Surface processing: ',lasterr]);
    disp(['Development only step. Continuing ...']);
end;

function [surfstruct,mc,inflatedSurf] = surfExtract(wmmask)
disp('Getting isosurface');
surfstruct = vtkIsoSurface(double(wmmask),int32(size(wmmask)),0.5,0);
disp('Preprocessing surface');
surfstruct = st_preprocess(surfstruct);
disp('Calculating curvature');
mc = st_curvature(surfstruct);
mc = st_abscurvature(surfstruct,mc);
disp('Inflating surface');
inflatedSurf = st_motionByMeanCurv(surfstruct,400,1.2);
fv.vertices = inflatedSurf.vertices;
fv.faces = inflatedSurf.faces;
inflatedSurf = fv;
